<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<title>synthe2foudingue</title>
<style>
html, body {
  margin:0;
  padding:0;
  font-family:Arial,sans-serif;
  height:100%;
  overflow:hidden;
  background:#fff;
}

#container {
  display:grid;
  grid-template-columns:65% 35%;
  height:100vh;
}

#stage {
  position:relative;
  background:white;
  overflow:hidden;
}

#preview {
  pointer-events: none;
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 8px;
  background: white;
  border: 1px solid #ddd;
  box-shadow: 0 8px 25px rgba(0,0,0,0.2);
  display: none;
  z-index: 1500;
}

#preview img {
  display: block;
  width: 220px;   /* taille de la vignette */
  height: auto;
}



.video-wrapper {
  position:absolute;
  cursor:move;
  mix-blend-mode:multiply;
  opacity:0.8;
  overflow:hidden;
  z-index:10; /* vidéos au-dessus */
}

video {
  display:block;
  filter: grayscale(100%) contrast(15) brightness(1.5) saturate(0.8);
  transform-origin:center center;
}

#viz {
  position:absolute;
  bottom:0;
  left:0;
  width:100%;
  height:200px;
  z-index:1; /* ligne en dessous */
}

#list {
  position:relative;
  padding:40px;
  font-size:16px;
  height:100%;
}

.synth-title {
  position:absolute;
  cursor:pointer;
  user-select:none;
  white-space:nowrap;
}

.synth-title:hover { text-decoration:underline; }

.note {
  margin-left:5px;
  color:black;
  font-weight:bold;
  display:none;
}

#downloadBtn {
  position: absolute;
  color:#fff;
  top: 10px;
  right: 10px;
  z-index:1000;
  padding:8px 12px;
  font-size:14px;
  cursor:crosshair;
  border-radius: 5px;
  background-color: rgb(65, 65, 65);
}

/* ========================= */
/* ===== MOBILE MODE ======= */
/* ========================= */
@media (max-width: 768px) {

  #container {
    grid-template-columns: 1fr;
    grid-template-rows: auto 1fr;
  }

  #stage {
    height: 55vh;
  }

  #viz {
    height: 120px;
  }

  #list {
    padding: 20px;
    font-size: 14px;
  }

  .synth-title {
    position: relative;
    display: block;
    margin-bottom: 12px;
    left: auto !important;
    top: auto !important;
  }

  /* bouton en bas */
  #downloadBtn {
    position: fixed;
    bottom: 20px;
    right: 20px;
    top: auto;
    font-size: 16px;
    padding: 12px 16px;
    z-index: 2000;
  }

  /* preview devient centrale */
  #preview {
    position: fixed;
    top: auto;
    bottom: 80px;
    right: 50%;
    transform: translateX(50%);
    margin-top: 0;
  }

  #preview img {
    width: 260px;
  }
}

</style>
</head>


<body>

<div id="container">
  <div id="stage">
    <canvas id="viz"></canvas>
  </div>
  <div id="list"></div>
</div>

<div style="position: absolute; top:10px; right:10px; z-index:1000;">
  <button id="downloadBtn">synthe review</button>

  <div id="preview">
    <img />
  </div>
</div>


<script>

  let previewActive = false;

  function previewLoop() {
  if (previewActive) {
    const canvas = generateFinalCanvas();
    if (canvas) {
      previewImg.src = canvas.toDataURL('image/png');
    }
  }
  requestAnimationFrame(previewLoop);
}

previewLoop();

// ===== CONFIG =====
const synthNames = [
  "[0] GS music e7",
  "[1] Buchla LEM218",
  "[2] Erica Synths Black System",
  "[3] Korg Minilogue",
  "[4] PWM Malevolent",
  "[5] Analogue Solutions Generator Sequencer",
  "[6] Behringer Model 15",
  "[7] 1010Music nanobox LemonDrop",
  "[8] Sequential Trigon 6",
];

const synths = synthNames.map((name,i)=>({
  key:String(i),
  name:name,
  video:`video${i+1}.mp4`,
  shape: ['smooth','sharp','noisy'][i % 3],
  phase: Math.random()*1000,
  speed: 0.3 + Math.random()*1.2,
  baseY: (Math.random()-0.5)*60
}));

// ===== CANVAS LIGNE =====
const canvas = document.getElementById('viz');
const ctx = canvas.getContext('2d');

function resizeCanvas(){
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

const stage = document.getElementById('stage');
const list = document.getElementById('list');
const activeVideos = {};

let frame = 0;
let linePhase = 0;
let lineSpeed = 0.01;

function drawLine(){
  requestAnimationFrame(drawLine);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const centerY = canvas.height / 2;
  const step = 3;

  let energy = 0;
  let activeCount = 0;
  let shapes = new Set();

  for(const key in activeVideos){
    const { video } = activeVideos[key];
    if(!video.paused){
      energy += video.volume;
      activeCount++;
      const synth = synths.find(s=>s.key===key);
      if(synth) shapes.add(synth.shape);
    }
  }

  energy = Math.min(energy, 1);

  // paramètres globaux de la ligne
  const amp      = 10 + energy * 60;
  const freq     = 0.01 + activeCount * 0.004;
  const chaos    = shapes.size * 0.3;
  lineSpeed      = 0.005 + energy * 0.02;

  linePhase += lineSpeed;

  ctx.beginPath();

  for(let x=0; x<=canvas.width; x+=step){
    let y = centerY;

    y += Math.sin(x*freq + linePhase) * amp;
    y += Math.sin(x*(freq*3) + linePhase*0.7) * amp*0.3;
    if(chaos > 0) y += (Math.random()-0.5) * chaos * 12;

    if(x===0) ctx.moveTo(x,y);
    else ctx.lineTo(x,y);
  }

  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.stroke();

  frame++;
}

drawLine();

// ===== UI VIDÉOS =====
synths.forEach(s=>{
  const title = document.createElement('div');
  title.className = 'synth-title';
  title.textContent = s.name;

  const note = document.createElement('span');
  note.className = 'note';
  note.textContent = '♪';
  title.appendChild(note);

  title.style.left = Math.random()*60 + '%';
  title.style.top  = Math.random()*90 + '%';
  list.appendChild(title);

  function toggle(){
    if(activeVideos[s.key]){
      const {video, wrapper} = activeVideos[s.key];
      video.pause();
      wrapper.remove();
      delete activeVideos[s.key];
      note.style.display = 'none';
      return;
    }

    const wrapper = document.createElement('div');
    wrapper.className = 'video-wrapper';

    const activeKeys = Object.keys(activeVideos);

    if(activeKeys.length > 0){
      // choisir une vidéo aléatoire déjà présente
      const randomKey = activeKeys[Math.floor(Math.random()*activeKeys.length)];
      const ref = activeVideos[randomKey].wrapper;

      // recouvrement léger sur un coin
      const overlap = 30 + Math.random()*20;
      const side = Math.floor(Math.random()*4);

      let x = ref.offsetLeft;
      let y = ref.offsetTop;

      if(side === 0) x += overlap;
      if(side === 1) x -= overlap;
      if(side === 2) y += overlap;
      if(side === 3) y -= overlap;

      wrapper.style.left = x + 'px';
      wrapper.style.top  = y + 'px';
    } else {
      wrapper.style.left = Math.random()*(stage.offsetWidth-200) + 'px';
      wrapper.style.top  = Math.random()*(stage.offsetHeight-200) + 'px';
    }

    wrapper.style.zIndex = Math.floor(Math.random()*50)+10;
    wrapper.style.opacity = 0.6 + Math.random()*0.4;

    const video = document.createElement('video');
    video.src = s.video;
    video.loop = true;
    video.volume = 0.7;
    video.playsInline = true;
    video.setAttribute('playsinline','');

    wrapper.appendChild(video);
    stage.appendChild(wrapper);

    video.addEventListener('loadedmetadata',()=>{
      const maxStart = Math.max(0, video.duration - 5);
      video.currentTime = Math.random()*maxStart;

      // dimensions réelles aléatoires
      const baseWidth  = 200 + Math.random()*260;
      const ratio = video.videoHeight / video.videoWidth;

      video.style.width  = baseWidth + 'px';
      video.style.height = (baseWidth * ratio) + 'px';

      // zoom aléatoire
      const zoom = 0.8 + Math.random()*0.7;
      video.style.transform = `scale(${zoom})`;

      video.play();
      note.style.display = 'inline';
    });

    activeVideos[s.key] = {video, wrapper};
  }

  title.addEventListener('click', toggle);
  document.addEventListener('keydown', e=>{
    if(e.key === s.key) toggle();
  });
});

function generateFinalCanvas() {
  const videosArray = Object.values(activeVideos);
  if (videosArray.length === 0) return null;

  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  videosArray.forEach(({ video, wrapper }) => {
    const rect = wrapper.getBoundingClientRect();
    const stageRect = stage.getBoundingClientRect();
    const scaleMatch = video.style.transform.match(/scale\(([^)]+)\)/);
    const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
    const w = video.videoWidth * scale;
    const h = video.videoHeight * scale;
    const x = rect.left - stageRect.left;
    const y = rect.top - stageRect.top;
    minX = Math.min(minX, x);
    minY = Math.min(minY, y);
    maxX = Math.max(maxX, x + w);
    maxY = Math.max(maxY, y + h);
  });

  const synthWidth  = maxX - minX;
  const synthHeight = maxY - minY;

  const padding = 40;
  const headerHeight = 50;
  const lineHeight = canvas.height;
  const textHeight = 20 * videosArray.length + 20;
  const totalWidth  = 600;
  const totalHeight = headerHeight + synthHeight + lineHeight + textHeight + 3*padding;

  const finalCanvas = document.createElement('canvas');
  finalCanvas.width = totalWidth;
  finalCanvas.height = totalHeight;
  const fctx = finalCanvas.getContext('2d');

  fctx.fillStyle = '#fff';
  fctx.fillRect(0, 0, totalWidth, totalHeight);

  // header
  fctx.fillStyle = 'black';
  fctx.font = 'bold 20px Arial';
  fctx.fillText('SYNTHE', padding, padding);
  fctx.fillText(
    'REVIEW',
    totalWidth - padding - fctx.measureText('REVIEW').width,
    padding
  );

  // vidéos
  videosArray
    .sort((a,b) => parseInt(a.wrapper.style.zIndex) - parseInt(b.wrapper.style.zIndex))
    .forEach(({ video, wrapper }) => {
      const rect = wrapper.getBoundingClientRect();
      const stageRect = stage.getBoundingClientRect();
      const scaleMatch = video.style.transform.match(/scale\(([^)]+)\)/);
      const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;
      const w = video.videoWidth * scale;
      const h = video.videoHeight * scale;
      const x = rect.left - stageRect.left - minX + padding;
      const y = rect.top - stageRect.top - minY + headerHeight + 2*padding;

      // récupérer styles visuels réels
const opacity = parseFloat(wrapper.style.opacity) || 1;
const blendMode = getComputedStyle(wrapper).mixBlendMode || 'normal';

// appliquer au canvas
fctx.save();
fctx.globalAlpha = opacity;
fctx.globalCompositeOperation = blendMode === 'multiply'
  ? 'multiply'
  : 'source-over';

fctx.filter = 'grayscale(100%) contrast(15) brightness(1.5) saturate(0.8)';
fctx.drawImage(video, x, y, w, h);

fctx.restore();

    });

  // ligne
  fctx.filter = 'none';
  fctx.drawImage(
    canvas,
    padding,
    totalHeight - lineHeight - padding,
    totalWidth - 2*padding,
    lineHeight
  );

  // liste synthés
  fctx.fillStyle = 'black';
  fctx.font = '16px Arial';
  videosArray.forEach(({ video }, i) => {
    const synth = synths.find(s => s.video === video.src.split('/').pop());
    if (synth) {
      fctx.fillText(
        `[${synth.key}]_${synth.name}`,
        padding,
        totalHeight - lineHeight - padding - textHeight + i*20
      );
    }
  });

  return finalCanvas;
}

const downloadBtn = document.getElementById('downloadBtn');
const preview = document.getElementById('preview');
const previewImg = preview.querySelector('img');

// PREVIEW AU SURVOL
downloadBtn.addEventListener('mouseenter', () => {
  const canvas = generateFinalCanvas();
  if (!canvas) return;
  previewImg.src = canvas.toDataURL('image/png');
  preview.style.display = 'block';
});

// CACHE LA PREVIEW
downloadBtn.addEventListener('mouseleave', () => {
  preview.style.display = 'none';
});

// DOWNLOAD AU CLIC
downloadBtn.addEventListener('click', () => {
  const canvas = generateFinalCanvas();
  if (!canvas) {
    alert("Aucune vidéo active !");
    return;
  }
  const link = document.createElement('a');
  link.download = 'synth_ticket.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
});

downloadBtn.addEventListener('mouseenter', () => {
  previewActive = true;
  preview.style.display = 'block';
});

downloadBtn.addEventListener('mouseleave', () => {
  previewActive = false;
  preview.style.display = 'none';
});




</script>

</body>
</html>